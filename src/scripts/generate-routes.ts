// Script to generate routes.generated.ts and routes.generated.json without starting the HTTP server.
// Usage: ts-node -r tsconfig-paths/register src/scripts/generate-routes.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from '../app.module';
import { ModulesContainer, Reflector } from '@nestjs/core';
import { PATH_METADATA, METHOD_METADATA } from '@nestjs/common/constants';
import { RequestMethod } from '@nestjs/common';
import * as fs from 'fs';
import * as path from 'path';

interface RouteMetaFlat {
  method: string;
  path: string;
  controller: string;
  handler: string;
  roles: string[];
}

async function generate() {
  const app = await NestFactory.createApplicationContext(AppModule, { logger: false });
  const modules = app.get(ModulesContainer);
  const reflector = app.get(Reflector);

  const globalPrefix = 'api/v1'; // Keep in sync with main.ts
  const flat: RouteMetaFlat[] = [];

  for (const moduleRef of modules.values()) {
    for (const ctrlWrapper of moduleRef.controllers.values()) {
      const controllerInstance = ctrlWrapper.instance;
      if (!controllerInstance) continue;
      const controllerClass = controllerInstance.constructor;
      const controllerPath = normalizePath(Reflect.getMetadata(PATH_METADATA, controllerClass));
      const controllerLevelRoles = reflector.get<any[]>('roles', controllerClass) || [];

      const prototype = controllerClass.prototype;
      for (const methodName of Object.getOwnPropertyNames(prototype)) {
        if (methodName === 'constructor') continue;
        const handler = prototype[methodName];
        const routePathMeta = Reflect.getMetadata(PATH_METADATA, handler);
        const methodMeta = Reflect.getMetadata(METHOD_METADATA, handler);
        if (methodMeta === undefined) continue;
        const method = RequestMethod[methodMeta];
        const methodLevelRoles = reflector.get<any[]>('roles', handler) || [];
        const effectiveRoles = methodLevelRoles.length ? methodLevelRoles : controllerLevelRoles;
        const routePaths = resolvePaths(controllerPath, routePathMeta).map(p => `/${globalPrefix}${p}`.replace(/\/+/g, '/'));
        for (const p of routePaths) {
          flat.push({ method, path: p, controller: controllerClass.name, handler: methodName, roles: effectiveRoles });
        }
      }
    }
  }

  flat.sort((a, b) => a.path.localeCompare(b.path) || a.method.localeCompare(b.method));

  const routesDir = path.join(process.cwd(), 'src', 'routes');
  if (!fs.existsSync(routesDir)) fs.mkdirSync(routesDir, { recursive: true });

  const tsFile = path.join(routesDir, 'routes.generated.ts');
  const jsonFile = path.join(routesDir, 'routes.generated.json');
  const header = `// AUTO-GENERATED ROUTES MAP\n// Generated by script at: ${new Date().toISOString()}\n// Do NOT edit manually.\n\n`;
  const body = `export interface GeneratedRouteMeta {\n  method: string;\n  path: string;\n  controller: string;\n  handler: string;\n  roles: string[];\n}\n\nexport const ROUTES_GENERATED: GeneratedRouteMeta[] = ${JSON.stringify(flat, null, 2)};\n`;

  fs.writeFileSync(tsFile, header + body, 'utf8');
  fs.writeFileSync(jsonFile, JSON.stringify({ generatedAt: new Date().toISOString(), routes: flat }, null, 2), 'utf8');
  // eslint-disable-next-line no-console
  console.log(`Generated ${flat.length} routes.`);
  await app.close();
}

function resolvePaths(controllerPath: string, routePathMeta: any): string[] {
  const methodPaths: string[] = [];
  const raw = routePathMeta ?? '';
  const routePaths = Array.isArray(raw) ? raw : [raw];
  for (const r of routePaths) {
    const full = [controllerPath, normalizePath(r)].filter(Boolean).join('/');
    methodPaths.push('/' + full.replace(/^\/+/, '').replace(/\/+/g, '/'));
  }
  return methodPaths;
}

function normalizePath(p: any): string {
  if (!p) return '';
  return String(p).replace(/^\/+/, '').replace(/\/+$/, '');
}

generate().catch(err => {
  // eslint-disable-next-line no-console
  console.error('Route generation failed', err);
  process.exit(1);
});
